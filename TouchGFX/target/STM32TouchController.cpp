/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : STM32TouchController.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN STM32TouchController */

#include <STM32TouchController.hpp>
#include "../ft6x06/ft6x06.h"
#include "stm32f4xx_hal.h"

extern "C"
{
    extern I2C_HandleTypeDef hi2c1;
    extern void MX_I2C1_Init(void);

    /** @brief With FT6206 : maximum 2 touches detected simultaneously
      */
#define TS_MAX_NB_TOUCH                 ((uint32_t) FT3X67_MAX_DETECTABLE_TOUCH)

#define TS_SWAP_NONE                    ((uint8_t) 0x01)
#define TS_SWAP_X                       ((uint8_t) 0x02)
#define TS_SWAP_Y                       ((uint8_t) 0x04)
#define TS_SWAP_XY                      ((uint8_t) 0x08)

#define TS_ORIENTATION_PORTRAIT         ((uint8_t) 0)
#define TS_ORIENTATION_LANDSCAPE        ((uint8_t) 1)
#define TS_ORIENTATION_LANDSCAPE_ROT180 ((uint8_t) 2)

#define TS_I2C_ADDRESS                   ((uint16_t)0x70)

    /**
    *  @brief TS_StateTypeDef
    *  Define TS State structure
    */
    typedef struct
    {
        uint8_t  touchDetected;                /*!< Total number of active touches detected at last scan */
        uint16_t touchX[TS_MAX_NB_TOUCH];      /*!< Touch X[0], X[1] coordinates on 12 bits */
        uint16_t touchY[TS_MAX_NB_TOUCH];      /*!< Touch Y[0], Y[1] coordinates on 12 bits */
    } TS_StateTypeDef;

    typedef enum
    {
        TS_OK                = 0x00, /*!< Touch Ok */
        TS_ERROR             = 0x01, /*!< Touch Error */
        TS_TIMEOUT           = 0x02, /*!< Touch Timeout */
        TS_DEVICE_NOT_FOUND  = 0x03  /*!< Touchscreen device not found */
    } TS_StatusTypeDef;

    static bool bsp_ts_initialized = false;
    static uint8_t  tsOrientation = TS_SWAP_NONE;

    static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef* i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t* Buffer, uint16_t Length);
    static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef* i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t* Buffer, uint16_t Length);
    static void I2Cx_Error(I2C_HandleTypeDef* i2c_handler, uint8_t Addr);

    /* TouchScreen (TS) BSP functions */
    __weak uint8_t BSP_TS_InitEx(uint16_t ts_SizeX, uint16_t ts_SizeY, uint8_t  orientation);
    __weak uint8_t BSP_TS_GetState(TS_StateTypeDef* TS_State);

    /* TouchScreen (TS) IO functions */
    __weak void     TS_IO_Init(void);
    __weak void     TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    __weak uint8_t  TS_IO_Read(uint8_t Addr, uint8_t Reg);
    __weak uint16_t TS_IO_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length);
    __weak void     TS_IO_WriteMultiple(uint8_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length);
    __weak void     TS_IO_Delay(uint32_t Delay);
}

using namespace touchgfx;

void STM32TouchController::init()
{
    int ts_init_nb_try = 10;

    for (; ts_init_nb_try > 0; ts_init_nb_try--)
    {
        if (BSP_TS_InitEx(240, 240, TS_ORIENTATION_LANDSCAPE) == TS_OK)
        {
            bsp_ts_initialized = true;
            break;
        }
    }

    assert(bsp_ts_initialized);
}

bool STM32TouchController::sampleTouch(int32_t& x, int32_t& y)
{
    /**
     * By default sampleTouch returns false,
     * return true if a touch has been detected, otherwise false.
     *
     * Coordinates are passed to the caller by reference by x and y.
     *
     * This function is called by the TouchGFX framework.
     * By default sampleTouch is called every tick, this can be adjusted by HAL::setTouchSampleRate(int8_t);
     *
     */
    static TS_StateTypeDef TS_State = { 0 };

    if (bsp_ts_initialized)
    {

        BSP_TS_GetState(&TS_State);

        if (TS_State.touchDetected)
        {
            x = TS_State.touchX[0];
            y = TS_State.touchY[0];
            return true;
        }
    }

    return false;
}

extern "C"
{
    /************************** LINK TS (TouchScreen) *****************************/
    /**
      * @brief  Initializes and configures the touch screen functionalities and
      *         configures all necessary hardware resources (GPIOs, I2C, clocks..)
      *         with a given orientation
      * @param  ts_SizeX : Maximum X size of the TS area on LCD
      * @param  ts_SizeY : Maximum Y size of the TS area on LCD
      * @param  orientation : TS_ORIENTATION_LANDSCAPE or TS_ORIENTATION_PORTRAIT
      * @retval TS_OK if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_TS_InitEx(uint16_t ts_SizeX, uint16_t ts_SizeY, uint8_t  orientation)
    {
        /* Note : TS_I2C_ADDRESS is un-initialized here, but is not used at all in init function */
        /* but the prototype of Init() is like that in template and should be respected       */

        /* Initialize the communication channel to sensor (I2C) if necessary */
        /* that is initialization is done only once after a power up         */
        ft3x67_ts_drv.Init(TS_I2C_ADDRESS);

        /* Scan FT6x36 TouchScreen IC controller ID register by I2C Read */
        /* Verify this is a FT6x36, otherwise this is an error case      */
        if (ft3x67_ts_drv.ReadID(TS_I2C_ADDRESS) != FT3X67_ID_VALUE)
        {
            return TS_DEVICE_NOT_FOUND;
        }

        /* Get LCD chosen orientation */
        if (orientation == TS_ORIENTATION_PORTRAIT)
        {
            tsOrientation = TS_SWAP_X | TS_SWAP_Y;
        }
        else if (orientation == TS_ORIENTATION_LANDSCAPE_ROT180)
        {
            tsOrientation = TS_SWAP_XY;
        }
        else
        {
            tsOrientation = TS_SWAP_XY | TS_SWAP_Y;
        }

        /* Software reset the TouchScreen */
        ft3x67_ts_drv.Reset(TS_I2C_ADDRESS);

        /* Calibrate, Configure and Start the TouchScreen driver */
        ft3x67_ts_drv.Start(TS_I2C_ADDRESS);

        return TS_OK;
    }

    /**
      * @brief  Returns status and positions of the touch screen.
      * @param  TS_State: Pointer to touch screen current state structure
      * @retval TS_OK if all initializations are OK. Other value if error.
      */
    __weak uint8_t BSP_TS_GetState(TS_StateTypeDef* TS_State)
    {
        static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
        static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
        uint8_t ts_status = TS_OK;
        uint16_t tmp;
        uint16_t Raw_x[TS_MAX_NB_TOUCH];
        uint16_t Raw_y[TS_MAX_NB_TOUCH];
        uint16_t xDiff;
        uint16_t yDiff;
        uint32_t index;

        /* Check and update the number of touches active detected */
        TS_State->touchDetected = ft3x67_ts_drv.DetectTouch(TS_I2C_ADDRESS);
        if (TS_State->touchDetected)
        {
            for (index = 0; index < TS_State->touchDetected; index++)
            {
                /* Get each touch coordinates */
                ft3x67_ts_drv.GetXY(TS_I2C_ADDRESS, &(Raw_x[index]), &(Raw_y[index]));

                if (tsOrientation & TS_SWAP_XY)
                {
                    tmp = Raw_x[index];
                    Raw_x[index] = Raw_y[index];
                    Raw_y[index] = tmp;
                }

                if (tsOrientation & TS_SWAP_X)
                {
                    Raw_x[index] = FT3X67_MAX_WIDTH - 1 - Raw_x[index];
                }

                if (tsOrientation & TS_SWAP_Y)
                {
                    Raw_y[index] = FT3X67_MAX_HEIGHT - 1 - Raw_y[index];
                }

                xDiff = Raw_x[index] > _x[index] ? (Raw_x[index] - _x[index]) : (_x[index] - Raw_x[index]);
                yDiff = Raw_y[index] > _y[index] ? (Raw_y[index] - _y[index]) : (_y[index] - Raw_y[index]);

                if ((xDiff + yDiff) > 5)
                {
                    _x[index] = Raw_x[index];
                    _y[index] = Raw_y[index];
                }
//

                TS_State->touchX[index] = _x[index];
                TS_State->touchY[index] = _y[index];

            } /* of for(index=0; index < TS_State->touchDetected; index++) */
        } /* end of if(TS_State->touchDetected != 0) */

        return (ts_status);
    }

    /**
      * @brief  Initializes Touchscreen low level.
      */
    __weak void TS_IO_Init(void)
    {
        //I2Cx_Init(&hi2c1);
    }

    /**
      * @brief  Writes a single data.
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @param  Value: Data to be written
      */
    __weak void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    {
        I2Cx_WriteMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&Value, 1);
    }

    /**
      * @brief  Reads a single data.
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @retval Data to be read
      */
    __weak uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
    {
        uint8_t read_value = 0;

        I2Cx_ReadMultiple(&hi2c1, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);

        return read_value;
    }

    /**
      * @brief  Reads multiple data with I2C communication
      *         channel from TouchScreen.
      * @param  Addr: I2C address
      * @param  Reg: Register address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval HAL status
      */
    __weak uint16_t TS_IO_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t* Buffer, uint16_t Length)
    {
        return I2Cx_ReadMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
    }

    /**
      * @brief  Delay function used in TouchScreen low level driver.
      * @param  Delay: Delay in ms
      */
    __weak void TS_IO_Delay(uint32_t Delay)
    {
        HAL_Delay(Delay);
    }

    /******************************* I2C Routines *********************************/
    /**
      * @brief  Reads multiple data.
      * @param  i2c_handler : I2C handler
      * @param  Addr: I2C address
      * @param  Reg: Reg address
      * @param  MemAddress: Memory address
      * @param  Buffer: Pointer to data buffer
      * @param  Length: Length of the data
      * @retval HAL status
      */
    static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef* i2c_handler,
                                               uint8_t Addr,
                                               uint16_t Reg,
                                               uint16_t MemAddress,
                                               uint8_t* Buffer,
                                               uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* I2C error occurred */
            I2Cx_Error(i2c_handler, Addr);
        }
        return status;
    }

    /**
      * @brief  Writes a value in a register of the device through BUS in using DMA mode.
      * @param  i2c_handler : I2C handler
      * @param  Addr: Device address on BUS Bus.
      * @param  Reg: The target register address to write
      * @param  MemAddress: Memory address
      * @param  Buffer: The target register value to be written
      * @param  Length: buffer size to be written
      * @retval HAL status
      */
    static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef* i2c_handler,
                                                uint8_t Addr,
                                                uint16_t Reg,
                                                uint16_t MemAddress,
                                                uint8_t* Buffer,
                                                uint16_t Length)
    {
        HAL_StatusTypeDef status = HAL_OK;

        status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);

        /* Check the communication status */
        if (status != HAL_OK)
        {
            /* Re-Initialize the I2C Bus */
            I2Cx_Error(i2c_handler, Addr);
        }
        return status;
    }

    /**
      * @brief  Manages error callback by re-initializing I2C.
      * @param  i2c_handler : I2C handler
      * @param  Addr: I2C Address
      */
    static void I2Cx_Error(I2C_HandleTypeDef* i2c_handler, uint8_t Addr)
    {
        /* De-initialize the I2C communication bus */
        HAL_I2C_DeInit(&hi2c1);

        /* Re-Initialize the I2C communication bus */
        MX_I2C1_Init();
    }
}
/* USER CODE END STM32TouchController */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
