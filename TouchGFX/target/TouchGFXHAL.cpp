/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : TouchGFXHAL.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

#include <TouchGFXHAL.hpp>

/* USER CODE BEGIN TouchGFXHAL.cpp */

#include "stm32f4xx_hal.h"
#include <touchgfx/hal/OSWrappers.hpp>
#include "main.h"

/* USER CODE BEGIN Includes */
#include "../st7789h2/st7789h2.h"
#include <touchgfx/hal/GPIO.hpp>
#include <CortexMMCUInstrumentation.hpp>
//#include <KeySampler.hpp>
#include "FreeRTOS.h"
#include "task.h"
/* USER CODE END Includes */

/* USER CODE BEGIN private defines */

/* USER CODE END private defines */

/* USER CODE BEGIN private variables */
volatile bool firstFrameReadyToDisplay = false;
static uint16_t* currFbBase = 0;
/* USER CODE END private variables */

/* USER CODE BEGIN private functions */

/* USER CODE END private functions */

/* USER CODE BEGIN extern C prototypes */
extern "C"
{
    typedef enum
    {
        IO_OK       = 0x00,
        IO_ERROR    = 0x01,
        IO_TIMEOUT  = 0x02,
        IO_ALREADY_INITIALIZED  = 0x03
    }
    IO_StatusTypeDef;
    /**
     * @brief LCD constroller Types Definition
     */
    typedef struct
    {
        __IO uint16_t REG;
        __IO uint16_t RAM;
    } LCD_CONTROLLER_TypeDef;

    /**
      * @brief  LCD status structure definition
      */
#define LCD_OK         ((uint8_t)0x00)
#define LCD_ERROR      ((uint8_t)0x01)
#define LCD_TIMEOUT    ((uint8_t)0x02)

    /** @defgroup STM32L496G_DISCOVERY_FMC FMC LCD Constants
      * @{
      */
    /* We use BANK1 as we use FMC_NE1 signal */
#define FMC_BANK1_BASE  ((uint32_t)(0x60000000 | 0x00000000))
#define FMC_BANK1       ((LCD_CONTROLLER_TypeDef *) FMC_BANK1_BASE)

    bool os_inited = false;

    __weak uint8_t BSP_LCD_InitEx(uint32_t orientation);
    __weak void BSP_LCD_Reset(void);
    void __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height);

    static void FMC_BANK1_WriteData(uint16_t Data);
    static uint16_t FMC_BANK1_ReadData(void);
}
/* USER CODE END extern C prototypes */

using namespace touchgfx;

/* USER CODE BEGIN private class objects */
static CortexMMCUInstrumentation mcuInstr;
// static KeySampler btnctrl;
/* USER CODE END private class objects */

void TouchGFXHAL::initialize()
{
    /* USER CODE BEGIN initialize step 1 */
    if (BSP_LCD_InitEx(ST7789H2_ORIENTATION_LANDSCAPE))
    {
        assert(0);
    }
    /* USER CODE END initialize step 1 */

    // Calling parent implementation of initialize().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.
    // Please note, HAL::initialize() must be called to initialize the framework.

    TouchGFXGeneratedHAL::initialize();

    /* USER CODE BEGIN initialize step 2 */
    lockDMAToFrontPorch(false);

    mcuInstr.init();
    setMCUInstrumentation(&mcuInstr);
    enableMCULoadCalculation(true);

    // setButtonController(&btnctrl);

    os_inited = true;
    /* USER CODE END initialize step 2 */
}

uint16_t* TouchGFXHAL::getTFTFrameBuffer() const
{
    return currFbBase;
}

void TouchGFXHAL::setTFTFrameBuffer(uint16_t* adr)
{
    currFbBase = adr;
}

void TouchGFXHAL::configureInterrupts()
{
}

void TouchGFXHAL::enableLCDControllerInterrupt()
{
}

void TouchGFXHAL::disableInterrupts()
{
}

void TouchGFXHAL::enableInterrupts()
{
}

// Full refresh
void TouchGFXHAL::flushFrameBuffer()
{
    Rect rect = Rect(0, 0, 240, 240);

    HAL::flushFrameBuffer();

    this->flushFrameBuffer(rect);

}

void  TouchGFXHAL::flushFrameBuffer(const Rect& rect)
{
    // Partial framebuffer might be supported for this platform only when Double
    // Buffering is enabled
    dma.flush();

    HAL::flushFrameBuffer(rect);

    /* Set Cursor */
    __ST7789H2_SetDisplayWindow(rect.x, rect.y, rect.width, rect.height);

    /* Prepare to write to LCD RAM */
    ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);

    /* Read dummy data */
    LCD_IO_ReadData();

    this->copyFrameBufferBlockToLCD(rect);
}

void TouchGFXHAL::copyFrameBufferBlockToLCD(const Rect rect)
{
    __IO uint16_t* ptr;
    int16_t height;

    // Use default implementation (CPU copy!).
    // This can be accelerated using regular DMA hardware
    for (height = 0; height < rect.height ; height++)
    {
        ptr = getClientFrameBuffer() + rect.x + (height + rect.y)  * 240;
        LCD_IO_WriteMultipleData((uint16_t*)ptr, rect.width);
    }
}

bool TouchGFXHAL::blockCopy(void* RESTRICT          dest,
                            const void* RESTRICT    src,
                            uint32_t            numBytes)
{
    bool retval = true;

    // Use default implementation (CPU copy!).
    // This can be accelerated using regular DMA hardware
    retval    = HAL::blockCopy(dest, src, numBytes);

    return retval;
}

/* USER CODE BEGIN virtual overloaded methods */
bool TouchGFXHAL::beginFrame()
{
    return HAL::beginFrame();
}

void TouchGFXHAL::endFrame()
{
    HAL::endFrame();
    if (frameBufferUpdatedThisFrame)
    {
        if (!firstFrameReadyToDisplay)
        {
            firstFrameReadyToDisplay = true;
            ST7789H2_DisplayOn();
        }
    }
}

/* USER CODE END virtual overloaded methods */

/* USER CODE BEGIN extern C functions */
// TODO : Remove this and use BSP/Components/st7789H2 API once fixed
extern "C" {

    portBASE_TYPE IdleTaskHook(void* p)
    {
        if ((int)p) //idle task sched out
        {
            touchgfx::HAL::getInstance()->setMCUActive(true);
        }
        else //idle task sched in
        {
            touchgfx::HAL::getInstance()->setMCUActive(false);
        }
        return pdTRUE;
    }

    void TouchGFX_TickHandler(uint8_t PinStatus)
    {
        if (os_inited)
        {
            if (PinStatus) /* Raising edge : entering Active Area */
            {
                HAL::getInstance()->vSync();
                OSWrappers::signalVSync();
                // Swap frame buffers immediately instead of waiting for the task to be scheduled in.
                // Note: task will also swap when it wakes up, but that operation is guarded and will not have
                // any effect if already swapped.
                HAL::getInstance()->swapFrameBuffers();
                GPIO::set(GPIO::VSYNC_FREQ);
            }
            else /* Falling edge : exiting active area */
            {
                GPIO::clear(GPIO::VSYNC_FREQ);
                HAL::getInstance()->frontPorchEntered();
            }
        }
    }

    /**
      * @brief  Writes register value.
      * @param  Data: Data to be written
      */
    static void FMC_BANK1_WriteData(uint16_t Data)
    {
        /* Write 16-bit Reg */
        FMC_BANK1->RAM = Data;
        __DSB();
    }

    /**
      * @brief  Writes register address.
      * @param  Reg: Register to be written
      */
    static void FMC_BANK1_WriteReg(uint8_t Reg)
    {
        /* Write 16-bit Index, then write register */
        FMC_BANK1->REG = Reg;
        __DSB();
    }

    /**
      * @brief  Reads register value.
      * @retval Read value
      */
    static uint16_t FMC_BANK1_ReadData(void)
    {
        return FMC_BANK1->RAM;
    }

    __weak void __ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)
    {
        uint8_t   parameter[4];

        /* CASET: Comumn Addrses Set */
        parameter[0] = 0x00;
        parameter[1] = Xpos;
        parameter[2] = 0x00;
        parameter[3] = Xpos + Width - 1;
        ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);
        /* RASET: Row Addrses Set */
        parameter[0] = 0x00;
        parameter[1] = Ypos;
        parameter[2] = 0x00;
        parameter[3] = Ypos + Height - 1;
        ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);
    }

    /**
      * @brief  Initializes the LCD with a given orientation.
      * @param  orientation: LCD_ORIENTATION_PORTRAIT or LCD_ORIENTATION_LANDSCAPE
      * @retval LCD status
      */
    __weak uint8_t BSP_LCD_InitEx(uint32_t orientation)
    {
        /* LCD Power On */
        //HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_RESET);

        /* Reset the LCD */
        BSP_LCD_Reset();

        if (ST7789H2_ReadID() == ST7789H2_ID)
        {
            /* LCD Init */
            ST7789H2_Init();

            if ((orientation == ST7789H2_ORIENTATION_PORTRAIT) || (orientation == ST7789H2_ORIENTATION_LANDSCAPE_ROT180))
            {
                ST7789H2_SetOrientation(orientation);
            }

            // ST7789H2_DisplayOff();
        }
        else
        {
            return LCD_ERROR;
        }

        /* Backlight control signal assertion */
        HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);

        return LCD_OK;
    }

    /**
      * @brief  Reset the LCD.
      * @param  None
      * @retval LCD state
      */
    __weak void BSP_LCD_Reset(void)
    {
        /* Apply hardware reset according to procedure indicated in FRD154BP2901 documentation */
        HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_RESET);
        HAL_Delay(5);   /* Reset signal asserted during 5ms  */
        HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_SET);
        HAL_Delay(10);  /* Reset signal released during 10ms */
        HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_RESET);
        HAL_Delay(20);  /* Reset signal asserted during 20ms */
        HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_SET);
        HAL_Delay(10);  /* Reset signal released during 10ms */
    }

}
/* USER CODE END extern C functions */

/* USER CODE END TouchGFXHAL.cpp */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
